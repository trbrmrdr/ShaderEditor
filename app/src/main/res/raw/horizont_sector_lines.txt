#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

#if 1
uniform vec2 mouse;
uniform vec2 resolution;
uniform float time;
#else

#if 0
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

#define time (u_time*.5)
#define mouse (u_mouse/u_resolution)
#define resolution u_resolution

#else

uniform float iGlobalTime;
uniform vec3 iMouse;
uniform vec2 iResolution;

#define time (iGlobalTime*.5)
#define mouse (iMouse.xy)
#define resolution iResolution

#endif

#endif
const float e = 2.718281828459;
const float pi = 3.14159265359;
float sin01( in float angle ) { return .5 + .5*sin( angle ); }
float cos01( in float angle ) { return .5 + .5*cos( angle ); }
float cosft( in float from, in float to, in float val ) { return from + cos01( val )*(to - from); }
float sinft( in float from, in float to, in float val ) { return from + sin01( val )*(to - from); }

float RandFloat( int i ) { return (fract( sin( float( i ) ) * 43758.5453 )); }
int RandInt( int i ) { return int( 100000.0*RandFloat( i ) ); }
//draw number 

float rand_1( float i )
{
#define DS 1000.
	//return fract(sin(DS+i*34.342)*cos(DS+i*123.5)*83.022);
	return RandFloat( int( i ) );
}

float rand_2( vec2 p )
{
	return fract( sin( p.x * 15.67 + p.y * 37.28 ) * 43758.26 );
}

float DigitBin( const in int x )
{
	return x == 0 ? 480599.0 : x == 1 ? 139810.0 : x == 2 ? 476951.0 : x == 3 ? 476999.0 : x == 4 ? 350020.0 : x == 5 ? 464711.0 : x == 6 ? 464727.0 : x == 7 ? 476228.0 : x == 8 ? 481111.0 : x == 9 ? 481095.0 : 0.0;
}

float PrintValue( const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces )
{
	vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;
	if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;
	float fLog10Value = log2( abs( fValue ) ) / log2( 10.0 );
	float fBiggestIndex = max( floor( fLog10Value ), 0.0 );
	float fDigitIndex = fMaxDigits - floor( vStringCharCoords.x );
	float fCharBin = 0.0;
	if (fDigitIndex > ( -fDecimalPlaces - 1.01 ))
	{
		if (fDigitIndex > fBiggestIndex)
		{
			if ((fValue < 0.0) && (fDigitIndex < (fBiggestIndex + 1.5))) fCharBin = 1792.0;
		}
		else
		{
			if (fDigitIndex == -1.0)
			{
				if (fDecimalPlaces > 0.0) fCharBin = 2.0;
			}
			else
			{
				if (fDigitIndex < 0.0) fDigitIndex += 1.0;
				float fDigitValue = (abs( fValue / (pow( 10.0, fDigitIndex )) ));
				float kFix = 0.0001;
				fCharBin = DigitBin( int( floor( mod( kFix + fDigitValue, 10.0 ) ) ) );
			}
		}
	}
	return floor( mod( (fCharBin / pow( 2.0, floor( fract( vStringCharCoords.x ) * 4.0 ) + (floor( vStringCharCoords.y * 5.0 ) * 4.0) )), 2.0 ) );
}


float drawText1 = .0;
vec3 drawText( vec2 position, vec3 color, const in float val )
{
	vec2 fontsize = vec2( 13.0, 15.0 );
	float prn = PrintValue( gl_FragCoord.xy, position, fontsize, val, 1.0, 6.0 );
	return mix( color, vec3( 1., 1.0, 0.5 ), prn );
}
//#############################
vec3 hsb2rgb( in vec3 c )
{
	vec3 rgb = clamp( abs( mod( c.x*6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );
	rgb = rgb * rgb*(3.0 - 2.0*rgb);
	return c.z * mix( vec3( 1.0 ), rgb, c.y );
}

vec4 HsvToRgb( vec4 c )
{
	float s = c.y * c.z;
	float s_n = c.z - s * .5;
	return vec4( s_n ) + vec4( s ) * cos( 2.0 * pi * (c.x + vec4( 1.0, 0.6666, .3333, 0.0 )) );
}

vec3 HsvToRgb( vec3 c )
{
	float s = c.y;
	float s_n = c.z - s * .5;
	return vec3( s_n ) + vec3( s ) * cos( 2.0 * pi * (c.x + vec3( 1.0, 0.6666, .3333 )) );
}
//###################
float m_LineWidth = 0.003;
float plot( in float fx, in vec2 uv )
{
	return  smoothstep( fx - m_LineWidth, fx, uv.y ) -
		smoothstep( fx, fx + m_LineWidth, uv.y );
}

vec3 m_LineColor = vec3( 1.0, .0, .0 );
vec3 plot_Fx( in float fx, in vec3 oldColor, in vec2 uv )
{
	float pct = plot( fx, uv );
	return  (1.0 - pct)*oldColor + pct * m_LineColor;
}


vec3 plot_Fy( in float fy, in vec3 oldColor, in vec2 uv )
{
	oldColor = plot_Fx( fy, oldColor, uv.yx );
	return oldColor;
}
//####################
//[-1;+1]
float VFx_t( float x, float t )
{
	//return cos(x+-1.780);
	float amplitude = 1.;
	float frequency = 1.;
	float y = sin( x * frequency );
	float t_t = 0.01*(-t * 130.0);
	y += sin( x*frequency*2.1 + t_t )*4.5;
	y += sin( x*frequency*1.72 + t_t * 1.121 )*4.0;
	y += sin( x*frequency*2.221 + t_t * 0.437 )*5.0;
	y += sin( x*frequency*3.1122 + t_t * 4.269 )*2.5;
	y *= amplitude * 0.06;
	return y;
}

float VFx_t01( float x, float t )
{
	return .5 + .5*VFx_t( x, t );
}

float circle1( vec2 uv, vec2 pos, float radius )
{
	float c_color = smoothstep( 0., radius, length( pos - uv ) );
	return 1. - floor( c_color );
}

float circle01( vec2 uv, vec2 pos, float radius )
{
	float c_color = smoothstep( 0., radius, length( pos - uv ) );
	return (1. - c_color)*2.;
}

float Fx( float x, vec2 scale )
{

    const float d_sig = 5.;
    float sc_y = scale.y/d_sig;
	float ret = smoothstep( -scale.x, 0., x )
		- smoothstep( .0, +scale.x, x );

	ret *= sc_y;
	float sig = sign( sc_y );
	//для Большей плавности к васшей точки изгиба у последующих копий ))))
	ret = smoothstep( .0, sig * d_sig, ret - sig ) * sc_y;
	//original ret = smoothstep(.0, 4.336, ret - 1.) * scale.y ;
	return ret;
}

//#undef time
//#define time (10.*1.936)

//#define TEST_ONCE
#ifndef TEST_ONCE

#define COUNT_L 15

const float max_w = 0.5 / float( COUNT_L );

const vec2 scale = vec2( .1, 2. )*3.;
const vec2 d_uv = vec2( 0., -.3 );
#else
#define COUNT_L 8

const float max_w = .000025 / float( COUNT_L );

const vec2 scale = vec2( .1, 2. )*4.;
const vec2 d_uv = vec2(-0.150,-0.420);
#endif

vec3 color = vec3( 0 );
//#define FUNC_VFX(id)	 ( max_w * (1. + VFx_t(id , time )) )
#define FUNC_VFX(id)	 ( max_w * (1. + VFx_t((id) + uv.y, uv.y - time )) )
struct Line
{
	float id;
	float id_2;

	float xs;
	float Vx;
	float c_pos;

	float eye_l;
	float eye_r;

	float eye_fl;
	float eye_fr;
    
	vec2 eye_pos;//todo удfлить x это всегда c_pos

	vec3 color_eye;

	vec2 scale_eye;
};

Line setLine(in Line line_in,in vec2 uv){
    Line line = line_in;
    line.xs = line.id / float( COUNT_L );
	line.id_2 = rand_1( line.id ) * 2.;
	line.Vx = FUNC_VFX( line.id_2 );
	line.c_pos = line.xs + line.Vx;
    return line;
}

Line setLine( in vec2 uv )
{
    Line line;
	line.id = floor( uv.x * float( COUNT_L ) );
    return setLine(line, uv);
}

Line setLine( in vec2 uv, in float id )
{
    Line line;
	line.id = id;
    return setLine(line, uv);
}

//____________________________________________________________
//original type
//const int recursionCount		= 8;	// how deep to recurse
float GetRecursionFade( int recursionCount, int r, float timePercent )
{
	if (r > recursionCount)
		return timePercent;

	// fade in and out recusion
	float rt = max( float( r ) - timePercent, 0.0 );
	float rc = float( recursionCount );
	return rt / rc;
}

vec3 CombinePixelColor( int recursionCount, vec3 color, float timePercent, int i, int r )
{
	vec3 myColor = vec3
	(
		mix( -0.1, 0.1, RandFloat( i + r ) ),
		mix( 0.0, 0.8, RandFloat( i + r + 100 ) ),
		mix( 0.0, 0.8, RandFloat( i + r + 200 ) )
	);

	// combine with my color
	float f = GetRecursionFade( recursionCount, r, timePercent );
	myColor.y = pow( myColor.y, 4.0 );
	myColor.z = pow( myColor.z, 4.0 );
	color += myColor * f;
	return color;
}

vec3 FinishPixel( vec3 color, vec2 uv )
{
	// color wander
	color.x += 0.02*time;

	//return color;
	// convert to rgb
	return HsvToRgb( color );
}
//____________________________________________________________

bool get_eye( in Line line_in,out Line line, in vec2 uv )
{
    line = line_in;
    //скорость раскрытия
	//---
    const vec2 max_scale = vec2( (4.32), (6.680) );
	//line.scale_eye = vec2(max_scale.x,1.15) ;
	line.scale_eye = max_scale * 1.;

	float udid = RandFloat( int( line.id ) );
	//t = .94;
	//t= .89+.04*sinft(.0,1.,line.id+t);
	float t_time = time * .3;
	line.scale_eye *= sinft( .0, 1.4, t_time + udid * scale.y );
	//line.scale_eye *= sinft(.0,1., t_time+line.id*t*scale.y );

#ifdef TEST_ONCE
	//test open eye
	line.scale_eye = max_scale * clamp( 0.968, .0, 1. );
    line.scale_eye = max_scale * sinft(.9,1.2,time*2.);//0.936;
#endif


	//скорость передвижения
	line.eye_pos.y = scale.y*(-1. + 3.*fract( .25*time*udid ));
	line.eye_pos.x = line.c_pos;

#ifdef TEST_ONCE
	//test pos eye
	line.eye_pos.y = 0.084;
#endif

	line.eye_fl = Fx( line.eye_pos.y - uv.y, -line.scale_eye );
	line.eye_fr = Fx( line.eye_pos.y - uv.y, line.scale_eye );

	//color += plot_Fy( pos_eye.x + fl ,color, uv);
	//color += plot_Fy( pos_eye.x + fr ,color, uv);
	//сама линия (line.xs + line.Vx) + глаз
	line.eye_l = line.c_pos + line.eye_fl;
	line.eye_r = line.c_pos + line.eye_fr;

	const float dw = .0001;
	float fill = smoothstep( line.eye_l, line.eye_l + dw, uv.x )
		- smoothstep( line.eye_r, line.eye_r + dw, uv.x );
    

	if (fill > .00001)
	{
        float t_l = smoothstep(line.eye_pos.x, line.eye_l, uv.x);
        float t_r = smoothstep(line.eye_pos.x, line.eye_r, uv.x);
        float to_dark_1 = pow(t_l + t_r, 2.9);
        
        
        float max_r = pow(Fx( line.eye_pos.y , line.scale_eye ) , .04);
        float to_dark_2 = 
             //smoothstep(.0, 
                            length( (line.eye_pos - uv) * line.scale_eye *vec2(2.,1.) / scale)// /max_r
                        
                        //, max_r*.25)
            ;
#if 0
        //тест позиции центра
        
        float it = to_dark_2*10.;
        float ret = it - floor(it);
        line.color_eye = vec3(
        //to_dark_2
            ret
             //+
            //smoothstep(line.eye_r, line.eye_pos.x, uv.x)
        );
        
        //line.color_eye = plot_Fy(line.eye_pos.x ,line.color_eye ,uv);
        //line.color_eye = plot_Fx(line.eye_pos.y ,line.color_eye ,uv);
        
        //line.color_eye = plot_Fy(line.eye_l ,line.color_eye ,uv);
        //line.color_eye = plot_Fy(line.eye_r ,line.color_eye ,uv);
        return true;
#endif
        

        //__________________________________________________________________________________________
        //первый вариант

	vec3 ret_col1 = vec3(to_dark_2);
#if 1
	{
        ret_col1 = hsb2rgb(
			vec3(
				RandFloat( int(
					to_dark_2*30. + line.id_2*line.id + time * 4.
					) )
				,
				1., 1.-to_dark_1
			) );
	}

#endif
//ув второй)
vec3 ret_col2 = vec3(.0);
#if 1   
	{
        float rand_id = RandFloat( int( line.id_2 ));
		float iterations = to_dark_2 * (25.*sinft( .5, 1., time ) + rand_id )+ time * -.5;
		float pct2 = iterations - floor( iterations );
		//_____
		const int recursionCount = 5;
		for (int r = 0; r <= recursionCount + 1; ++r)
			ret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + rand_id * time ), r );

		ret_col2.x += time * 1.5;
		ret_col2 = HsvToRgb( ret_col2 );
	}
#endif
     
        ret_col2 = mix(ret_col2,vec3(.0),to_dark_1);
		color = mix(
            ret_col1,
            ret_col2,
            //0.
            sinft(.0,1.,time*udid)
        );

        //color = vec3(to_dark_2);


#if 0 //type eye
		if (mod( line.id, 2. ) > .5)return true;
		vec2 tuv = line.eye_pos - uv;
		tuv *= line.scale_eye / scale;
		//tuv.y *= line.scale_eye.y / (scale.y*.25);

		float angle = atan( tuv.y, tuv.x ) + time * 5.;
		float r = length( tuv ) / line.scale_eye.x*2.5;


		float sign = mod( r, sinft( .5, 1.000,
									time*.5
		) ) >= 0.25 ? -1. : +1.;
		//sign = 1.;

		float it_sp = 100.*(-1.620 * sqrt( r ) + angle * (-.060 * sign));

		float sp = cos( it_sp );
		float sp_2 = sp;
		sp = sp > .5*r ? 1. : .0;

		//line.color_eye = vec3(sp);
		//line.color_eye = mix(vec3(sp), line.color_eye ,sinft(.0, 1., time*4.) );
		///*
		line.color_eye = mix(//hsb2rgb(vec3(sp,sp,to_dark)), 
							  vec3( sp ),
							  hsb2rgb( vec3(
								  RandFloat( int(
									  sign*(r + time * .5)*10.
									  ) )
								  , 1., to_dark_2 ) ),

							  sinft( .0, 1.5, time ) * sp_2 * r );
		/**/



#endif
		return true;
		//line.color_eye = vec3(t_eye);
	}
    return false;
}


void main()
{
	vec2 uv = gl_FragCoord.xy / resolution.xy;
	uv.x *= resolution.x / resolution.y;

	uv += d_uv;
	uv *= scale;

    
	Line line_c = setLine( uv );
	//color += plot_Fy(line_c.xs,color,uv);    
    //gl_FragColor = vec4(line_c.id, line_c.id_2, 0., 1.);
    //return;
	//############################
	//sector____centr
	m_LineColor = vec3( 0, 1, 1 );
	m_LineWidth = 0.003;
	//if(t_id_c >= 1. && t_id_c<=4.)
	//    plot_Fy(t_id_xs + t_id_Vx ,color,uv);
	//plot_Fy(t_id_xs + t_id_Vx ,color,uv);
	//###################################### sectors
	Line line_l = setLine(uv, line_c.id - 1. );
	//###_____right
	Line line_r = setLine(uv, line_c.id + 1. );
	//plot_Fx(t_id_xs + t_id_Vx ,color,uv.yx);
	//############################
	float id2 = line_c.id;
	float t_s1 = line_c.c_pos;
	float t_s2 = line_r.c_pos;
    bool hasEye = get_eye( line_c,line_c, uv );
    color += line_c.color_eye;
    
	if (uv.x < line_c.c_pos)
	{//l - c
		id2 = line_l.id;
		t_s1 = line_l.c_pos;
		t_s2 = line_c.c_pos;

		hasEye = hasEye || get_eye(line_l, line_l, uv );

		color += line_l.color_eye;
        
		t_s1 += line_l.eye_fr;
		t_s2 += line_c.eye_fl;

	}
	else
	{
		// c - r
		hasEye = hasEye || get_eye(line_r, line_r, uv );

        color += line_r.color_eye;
        
		t_s1 += line_c.eye_fr;
		t_s2 += line_r.eye_fl;
	}

	
	float pct = smoothstep( t_s1, t_s2, uv.x );
	//color lines
	//pct - чб градиент от центра (тут насыщенность перехода)
	pct = pow( 1.760*pct*(1.0 - pct), 1.1 );//0.376 );
											//pct = 1.-pct;
											///______________________
											//тип цвета градиента
	//первый вариант
	vec3 ret_col1 = vec3(pct);
#if 1
	{
#define gen_col(val) VFx_t01( id2 + pct * uv.y + (val), (val) + uv.y + time + floor(pct*60.))
		float r = gen_col( 0.450 );
		float g = gen_col( 1.3445 );
		float b = gen_col( 2.021 );
		ret_col1 += (vec3( r, g, b )*pct) / (-.25888) + pct;
		//color += vec3(r,g,b)/(-.5888)+pct;
		//color += hsb2rgb(vec3(VFx_t01(uv.x+id2,time+uv.y),1.,1.));
		ret_col1 += hsb2rgb( vec3(
			RandFloat( int(
			(id2*10.0001 + pct * 3. + time * .1) / .1
				) ) + fract( time*.2 )
			, 1., pct ) );
	}

//ув второй)
vec3 ret_col2 = vec3(.0);
	{
		//чб градиент умножаем его и двигаем со временем
		//float iterations =  pct*10. + u_time*-.5;//original
		float iterations = pct * (100.*sinft( .5, 1., time ) + RandFloat( int( id2 ) )) + time * -.5;
		float pct2 = iterations - floor( iterations );
		//_____
		const int recursionCount = 5;
		for (int r = 0; r <= recursionCount + 1; ++r)
			ret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + id2 * time ), r );
		//original
		//new_color =  FinishPixel(new_color, uv);

		//color.x += 0.02*u_time;
		//return HsvToRgb(color);

		ret_col2.x += time * .5;
		ret_col2 = HsvToRgb( ret_col2 );
	}
    if(!hasEye){
		color = mix(ret_col1,ret_col2,sinft(.0,
                                            //3. * sinft(.125,1.,time)
                                            1.
                                            ,time));
        //color = vec3(pow(.5,1.-pct));
        //color =  ret_col2;
    }
    //else color = vec3(1.);
    
#else
    color = vec3(pct);
#endif

	



	//color = drawText(resolution * vec2(0.720,0.900),color,drawText1);
	//############################
	gl_FragColor = vec4( color, 1.0 );
}